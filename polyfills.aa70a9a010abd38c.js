"use strict";(self.webpackChunksr_traffic=self.webpackChunksr_traffic||[]).push([[429],{565:(or,mn,Yn)=>{Error;const qo=function(s,...e){if(qo.translate){const n=qo.translate(s,e);s=n[0],e=n[1]}let t=Gl(s[0],s.raw[0]);for(let n=1;n<s.length;n++)t+=e[n-1]+Gl(s[n],s.raw[n]);return t};function Gl(s,e){return":"===e.charAt(0)?s.substring(function jl(s,e){for(let t=1,n=1;t<s.length;t++,n++)if("\\"===e[n])n++;else if(":"===s[t])return t;throw new Error(`Unterminated $localize metadata block in "${e}".`)}(s,e)+1):s}(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)().$localize=qo,Yn(583)},583:()=>{!function(f){const v=f.performance;function x(le){v&&v.mark&&v.mark(le)}function m(le,H){v&&v.measure&&v.measure(le,H)}x("Zone");const T=f.__Zone_symbol_prefix||"__zone_symbol__";function I(le){return T+le}const B=!0===f[I("forceDuplicateZoneCheck")];if(f.Zone){if(B||"function"!=typeof f.Zone.__symbol__)throw new Error("Zone already loaded.");return f.Zone}let V=(()=>{class le{constructor(d,y){this._parent=d,this._name=y?y.name||"unnamed":"<root>",this._properties=y&&y.properties||{},this._zoneDelegate=new F(this,this._parent&&this._parent._zoneDelegate,y)}static assertZonePatched(){if(f.Promise!==$e.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}static get root(){let d=le.current;for(;d.parent;)d=d.parent;return d}static get current(){return ue.zone}static get currentTask(){return tt}static __load_patch(d,y,W=!1){if($e.hasOwnProperty(d)){if(!W&&B)throw Error("Already loaded patch: "+d)}else if(!f["__Zone_disable_"+d]){const Y="Zone:"+d;x(Y),$e[d]=y(f,le,et),m(Y,Y)}}get parent(){return this._parent}get name(){return this._name}get(d){const y=this.getZoneWith(d);if(y)return y._properties[d]}getZoneWith(d){let y=this;for(;y;){if(y._properties.hasOwnProperty(d))return y;y=y._parent}return null}fork(d){if(!d)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,d)}wrap(d,y){if("function"!=typeof d)throw new Error("Expecting function got: "+d);const W=this._zoneDelegate.intercept(this,d,y),Y=this;return function(){return Y.runGuarded(W,this,arguments,y)}}run(d,y,W,Y){ue={parent:ue,zone:this};try{return this._zoneDelegate.invoke(this,d,y,W,Y)}finally{ue=ue.parent}}runGuarded(d,y=null,W,Y){ue={parent:ue,zone:this};try{try{return this._zoneDelegate.invoke(this,d,y,W,Y)}catch(Ue){if(this._zoneDelegate.handleError(this,Ue))throw Ue}}finally{ue=ue.parent}}runTask(d,y,W){if(d.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(d.zone||Te).name+"; Execution: "+this.name+")");if(d.state===re&&(d.type===X||d.type===fe))return;const Y=d.state!=Pe;Y&&d._transitionTo(Pe,oe),d.runCount++;const Ue=tt;tt=d,ue={parent:ue,zone:this};try{d.type==fe&&d.data&&!d.data.isPeriodic&&(d.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,d,y,W)}catch(D){if(this._zoneDelegate.handleError(this,D))throw D}}finally{d.state!==re&&d.state!==Re&&(d.type==X||d.data&&d.data.isPeriodic?Y&&d._transitionTo(oe,Pe):(d.runCount=0,this._updateTaskCount(d,-1),Y&&d._transitionTo(re,Pe,re))),ue=ue.parent,tt=Ue}}scheduleTask(d){if(d.zone&&d.zone!==this){let W=this;for(;W;){if(W===d.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${d.zone.name}`);W=W.parent}}d._transitionTo(J,re);const y=[];d._zoneDelegates=y,d._zone=this;try{d=this._zoneDelegate.scheduleTask(this,d)}catch(W){throw d._transitionTo(Re,J,re),this._zoneDelegate.handleError(this,W),W}return d._zoneDelegates===y&&this._updateTaskCount(d,1),d.state==J&&d._transitionTo(oe,J),d}scheduleMicroTask(d,y,W,Y){return this.scheduleTask(new q(G,d,y,W,Y,void 0))}scheduleMacroTask(d,y,W,Y,Ue){return this.scheduleTask(new q(fe,d,y,W,Y,Ue))}scheduleEventTask(d,y,W,Y,Ue){return this.scheduleTask(new q(X,d,y,W,Y,Ue))}cancelTask(d){if(d.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(d.zone||Te).name+"; Execution: "+this.name+")");d._transitionTo(P,oe,Pe);try{this._zoneDelegate.cancelTask(this,d)}catch(y){throw d._transitionTo(Re,P),this._zoneDelegate.handleError(this,y),y}return this._updateTaskCount(d,-1),d._transitionTo(re,P),d.runCount=0,d}_updateTaskCount(d,y){const W=d._zoneDelegates;-1==y&&(d._zoneDelegates=null);for(let Y=0;Y<W.length;Y++)W[Y]._updateTaskCount(d.type,y)}}return le.__symbol__=I,le})();const j={name:"",onHasTask:(le,H,d,y)=>le.hasTask(d,y),onScheduleTask:(le,H,d,y)=>le.scheduleTask(d,y),onInvokeTask:(le,H,d,y,W,Y)=>le.invokeTask(d,y,W,Y),onCancelTask:(le,H,d,y)=>le.cancelTask(d,y)};class F{constructor(H,d,y){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=H,this._parentDelegate=d,this._forkZS=y&&(y&&y.onFork?y:d._forkZS),this._forkDlgt=y&&(y.onFork?d:d._forkDlgt),this._forkCurrZone=y&&(y.onFork?this.zone:d._forkCurrZone),this._interceptZS=y&&(y.onIntercept?y:d._interceptZS),this._interceptDlgt=y&&(y.onIntercept?d:d._interceptDlgt),this._interceptCurrZone=y&&(y.onIntercept?this.zone:d._interceptCurrZone),this._invokeZS=y&&(y.onInvoke?y:d._invokeZS),this._invokeDlgt=y&&(y.onInvoke?d:d._invokeDlgt),this._invokeCurrZone=y&&(y.onInvoke?this.zone:d._invokeCurrZone),this._handleErrorZS=y&&(y.onHandleError?y:d._handleErrorZS),this._handleErrorDlgt=y&&(y.onHandleError?d:d._handleErrorDlgt),this._handleErrorCurrZone=y&&(y.onHandleError?this.zone:d._handleErrorCurrZone),this._scheduleTaskZS=y&&(y.onScheduleTask?y:d._scheduleTaskZS),this._scheduleTaskDlgt=y&&(y.onScheduleTask?d:d._scheduleTaskDlgt),this._scheduleTaskCurrZone=y&&(y.onScheduleTask?this.zone:d._scheduleTaskCurrZone),this._invokeTaskZS=y&&(y.onInvokeTask?y:d._invokeTaskZS),this._invokeTaskDlgt=y&&(y.onInvokeTask?d:d._invokeTaskDlgt),this._invokeTaskCurrZone=y&&(y.onInvokeTask?this.zone:d._invokeTaskCurrZone),this._cancelTaskZS=y&&(y.onCancelTask?y:d._cancelTaskZS),this._cancelTaskDlgt=y&&(y.onCancelTask?d:d._cancelTaskDlgt),this._cancelTaskCurrZone=y&&(y.onCancelTask?this.zone:d._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const W=y&&y.onHasTask;(W||d&&d._hasTaskZS)&&(this._hasTaskZS=W?y:j,this._hasTaskDlgt=d,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=H,y.onScheduleTask||(this._scheduleTaskZS=j,this._scheduleTaskDlgt=d,this._scheduleTaskCurrZone=this.zone),y.onInvokeTask||(this._invokeTaskZS=j,this._invokeTaskDlgt=d,this._invokeTaskCurrZone=this.zone),y.onCancelTask||(this._cancelTaskZS=j,this._cancelTaskDlgt=d,this._cancelTaskCurrZone=this.zone))}fork(H,d){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,H,d):new V(H,d)}intercept(H,d,y){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,H,d,y):d}invoke(H,d,y,W,Y){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,H,d,y,W,Y):d.apply(y,W)}handleError(H,d){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,H,d)}scheduleTask(H,d){let y=d;if(this._scheduleTaskZS)this._hasTaskZS&&y._zoneDelegates.push(this._hasTaskDlgtOwner),y=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,H,d),y||(y=d);else if(d.scheduleFn)d.scheduleFn(d);else{if(d.type!=G)throw new Error("Task is missing scheduleFn.");E(d)}return y}invokeTask(H,d,y,W){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,H,d,y,W):d.callback.apply(y,W)}cancelTask(H,d){let y;if(this._cancelTaskZS)y=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,H,d);else{if(!d.cancelFn)throw Error("Task is not cancelable");y=d.cancelFn(d)}return y}hasTask(H,d){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,H,d)}catch(y){this.handleError(H,y)}}_updateTaskCount(H,d){const y=this._taskCounts,W=y[H],Y=y[H]=W+d;if(Y<0)throw new Error("More tasks executed then were scheduled.");0!=W&&0!=Y||this.hasTask(this.zone,{microTask:y.microTask>0,macroTask:y.macroTask>0,eventTask:y.eventTask>0,change:H})}}class q{constructor(H,d,y,W,Y,Ue){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=H,this.source=d,this.data=W,this.scheduleFn=Y,this.cancelFn=Ue,!y)throw new Error("callback is not defined");this.callback=y;const D=this;this.invoke=H===X&&W&&W.useG?q.invokeTask:function(){return q.invokeTask.call(f,D,this,arguments)}}static invokeTask(H,d,y){H||(H=this),rt++;try{return H.runCount++,H.zone.runTask(H,d,y)}finally{1==rt&&Ee(),rt--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(re,J)}_transitionTo(H,d,y){if(this._state!==d&&this._state!==y)throw new Error(`${this.type} '${this.source}': can not transition to '${H}', expecting state '${d}'${y?" or '"+y+"'":""}, was '${this._state}'.`);this._state=H,H==re&&(this._zoneDelegates=null)}toString(){return this.data&&typeof this.data.handleId<"u"?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const ge=I("setTimeout"),se=I("Promise"),de=I("then");let O,Ne=[],pe=!1;function E(le){if(0===rt&&0===Ne.length)if(O||f[se]&&(O=f[se].resolve(0)),O){let H=O[de];H||(H=O.then),H.call(O,Ee)}else f[ge](Ee,0);le&&Ne.push(le)}function Ee(){if(!pe){for(pe=!0;Ne.length;){const le=Ne;Ne=[];for(let H=0;H<le.length;H++){const d=le[H];try{d.zone.runTask(d,null,null)}catch(y){et.onUnhandledError(y)}}}et.microtaskDrainDone(),pe=!1}}const Te={name:"NO ZONE"},re="notScheduled",J="scheduling",oe="scheduled",Pe="running",P="canceling",Re="unknown",G="microTask",fe="macroTask",X="eventTask",$e={},et={symbol:I,currentZoneFrame:()=>ue,onUnhandledError:Ce,microtaskDrainDone:Ce,scheduleMicroTask:E,showUncaughtError:()=>!V[I("ignoreConsoleErrorUncaughtError")],patchEventTarget:()=>[],patchOnProperties:Ce,patchMethod:()=>Ce,bindArguments:()=>[],patchThen:()=>Ce,patchMacroTask:()=>Ce,patchEventPrototype:()=>Ce,isIEOrEdge:()=>!1,getGlobalObjects:()=>{},ObjectDefineProperty:()=>Ce,ObjectGetOwnPropertyDescriptor:()=>{},ObjectCreate:()=>{},ArraySlice:()=>[],patchClass:()=>Ce,wrapWithCurrentZone:()=>Ce,filterProperties:()=>[],attachOriginToPatched:()=>Ce,_redefineProperty:()=>Ce,patchCallbacks:()=>Ce};let ue={parent:null,zone:new V(null,null)},tt=null,rt=0;function Ce(){}m("Zone","Zone"),f.Zone=V}(typeof window<"u"&&window||typeof self<"u"&&self||global);const mn=Object.getOwnPropertyDescriptor,Yn=Object.defineProperty,Le=Object.getPrototypeOf,_t=Object.create,_s=Array.prototype.slice,Pn="addEventListener",ys="removeEventListener",Qn=Zone.__symbol__(Pn),kn=Zone.__symbol__(ys),K="true",At="false",jt=Zone.__symbol__("");function Ln(f,v){return Zone.current.wrap(f,v)}function Jn(f,v,x,m,T){return Zone.current.scheduleMacroTask(f,v,x,m,T)}const me=Zone.__symbol__,Qt=typeof window<"u",gn=Qt?window:void 0,Ve=Qt&&gn||"object"==typeof self&&self||global,Oe=[null];function st(f,v){for(let x=f.length-1;x>=0;x--)"function"==typeof f[x]&&(f[x]=Ln(f[x],v+"_"+x));return f}function es(f){return!f||!1!==f.writable&&!("function"==typeof f.get&&typeof f.set>"u")}const ar=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,ce=!("nw"in Ve)&&typeof Ve.process<"u"&&"[object process]"==={}.toString.call(Ve.process),Ge=!ce&&!ar&&!(!Qt||!gn.HTMLElement),ur=typeof Ve.process<"u"&&"[object process]"==={}.toString.call(Ve.process)&&!ar&&!(!Qt||!gn.HTMLElement),ts={},lr=function(f){if(!(f=f||Ve.event))return;let v=ts[f.type];v||(v=ts[f.type]=me("ON_PROPERTY"+f.type));const x=this||f.target||Ve,m=x[v];let T;if(Ge&&x===gn&&"error"===f.type){const I=f;T=m&&m.call(this,I.message,I.filename,I.lineno,I.colno,I.error),!0===T&&f.preventDefault()}else T=m&&m.apply(this,arguments),null!=T&&!T&&f.preventDefault();return T};function Rn(f,v,x){let m=mn(f,v);if(!m&&x&&mn(x,v)&&(m={enumerable:!0,configurable:!0}),!m||!m.configurable)return;const T=me("on"+v+"patched");if(f.hasOwnProperty(T)&&f[T])return;delete m.writable,delete m.value;const I=m.get,B=m.set,V=v.substr(2);let j=ts[V];j||(j=ts[V]=me("ON_PROPERTY"+V)),m.set=function(F){let q=this;!q&&f===Ve&&(q=Ve),q&&(q[j]&&q.removeEventListener(V,lr),B&&B.apply(q,Oe),"function"==typeof F?(q[j]=F,q.addEventListener(V,lr,!1)):q[j]=null)},m.get=function(){let F=this;if(!F&&f===Ve&&(F=Ve),!F)return null;const q=F[j];if(q)return q;if(I){let ge=I&&I.call(this);if(ge)return m.set.call(this,ge),"function"==typeof F.removeAttribute&&F.removeAttribute(v),ge}return null},Yn(f,v,m),f[T]=!0}function ui(f,v,x){if(v)for(let m=0;m<v.length;m++)Rn(f,"on"+v[m],x);else{const m=[];for(const T in f)"on"==T.substr(0,2)&&m.push(T);for(let T=0;T<m.length;T++)Rn(f,m[T],x)}}const yt=me("originalInstance");function Mn(f){const v=Ve[f];if(!v)return;Ve[me(f)]=v,Ve[f]=function(){const T=st(arguments,f);switch(T.length){case 0:this[yt]=new v;break;case 1:this[yt]=new v(T[0]);break;case 2:this[yt]=new v(T[0],T[1]);break;case 3:this[yt]=new v(T[0],T[1],T[2]);break;case 4:this[yt]=new v(T[0],T[1],T[2],T[3]);break;default:throw new Error("Arg list too long.")}},bt(Ve[f],v);const x=new v(function(){});let m;for(m in x)"XMLHttpRequest"===f&&"responseBlob"===m||function(T){"function"==typeof x[T]?Ve[f].prototype[T]=function(){return this[yt][T].apply(this[yt],arguments)}:Yn(Ve[f].prototype,T,{set:function(I){"function"==typeof I?(this[yt][T]=Ln(I,f+"."+T),bt(this[yt][T],I)):this[yt][T]=I},get:function(){return this[yt][T]}})}(m);for(m in v)"prototype"!==m&&v.hasOwnProperty(m)&&(Ve[f][m]=v[m])}function Bt(f,v,x){let m=f;for(;m&&!m.hasOwnProperty(v);)m=Le(m);!m&&f[v]&&(m=f);const T=me(v);let I=null;if(m&&(!(I=m[T])||!m.hasOwnProperty(T))&&(I=m[T]=m[v],es(m&&mn(m,v)))){const V=x(I,T,v);m[v]=function(){return V(this,arguments)},bt(m[v],I)}return I}function li(f,v,x){let m=null;function T(I){const B=I.data;return B.args[B.cbIdx]=function(){I.invoke.apply(this,arguments)},m.apply(B.target,B.args),I}m=Bt(f,v,I=>function(B,V){const j=x(B,V);return j.cbIdx>=0&&"function"==typeof V[j.cbIdx]?Jn(j.name,V[j.cbIdx],j,T):I.apply(B,V)})}function bt(f,v){f[me("OriginalDelegate")]=v}let cr=!1,vn=!1;function ws(){if(cr)return vn;cr=!0;try{const f=gn.navigator.userAgent;(-1!==f.indexOf("MSIE ")||-1!==f.indexOf("Trident/")||-1!==f.indexOf("Edge/"))&&(vn=!0)}catch{}return vn}Zone.__load_patch("ZoneAwarePromise",(f,v,x)=>{const m=Object.getOwnPropertyDescriptor,T=Object.defineProperty,B=x.symbol,V=[],j=!0===f[B("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],F=B("Promise"),q=B("then");x.onUnhandledError=D=>{if(x.showUncaughtError()){const S=D&&D.rejection;S?console.error("Unhandled Promise rejection:",S instanceof Error?S.message:S,"; Zone:",D.zone.name,"; Task:",D.task&&D.task.source,"; Value:",S,S instanceof Error?S.stack:void 0):console.error(D)}},x.microtaskDrainDone=()=>{for(;V.length;){const D=V.shift();try{D.zone.runGuarded(()=>{throw D.throwOriginal?D.rejection:D})}catch(S){de(S)}}};const se=B("unhandledPromiseRejectionHandler");function de(D){x.onUnhandledError(D);try{const S=v[se];"function"==typeof S&&S.call(this,D)}catch{}}function Ne(D){return D&&D.then}function pe(D){return D}function O(D){return d.reject(D)}const E=B("state"),Ee=B("value"),Te=B("finally"),re=B("parentPromiseValue"),J=B("parentPromiseState"),Pe=null,P=!0,Re=!1;function fe(D,S){return b=>{try{ue(D,S,b)}catch(R){ue(D,!1,R)}}}const et=B("currentTaskTrace");function ue(D,S,b){const R=function(){let D=!1;return function(b){return function(){D||(D=!0,b.apply(null,arguments))}}}();if(D===b)throw new TypeError("Promise resolved with itself");if(D[E]===Pe){let ne=null;try{("object"==typeof b||"function"==typeof b)&&(ne=b&&b.then)}catch(ee){return R(()=>{ue(D,!1,ee)})(),D}if(S!==Re&&b instanceof d&&b.hasOwnProperty(E)&&b.hasOwnProperty(Ee)&&b[E]!==Pe)rt(b),ue(D,b[E],b[Ee]);else if(S!==Re&&"function"==typeof ne)try{ne.call(b,R(fe(D,S)),R(fe(D,!1)))}catch(ee){R(()=>{ue(D,!1,ee)})()}else{D[E]=S;const ee=D[Ee];if(D[Ee]=b,D[Te]===Te&&S===P&&(D[E]=D[J],D[Ee]=D[re]),S===Re&&b instanceof Error){const z=v.currentTask&&v.currentTask.data&&v.currentTask.data.__creationTrace__;z&&T(b,et,{configurable:!0,enumerable:!1,writable:!0,value:z})}for(let z=0;z<ee.length;)Ce(D,ee[z++],ee[z++],ee[z++],ee[z++]);if(0==ee.length&&S==Re){D[E]=0;let z=b;try{throw new Error("Uncaught (in promise): "+function I(D){return D&&D.toString===Object.prototype.toString?(D.constructor&&D.constructor.name||"")+": "+JSON.stringify(D):D?D.toString():Object.prototype.toString.call(D)}(b)+(b&&b.stack?"\n"+b.stack:""))}catch($){z=$}j&&(z.throwOriginal=!0),z.rejection=b,z.promise=D,z.zone=v.current,z.task=v.currentTask,V.push(z),x.scheduleMicroTask()}}}return D}const tt=B("rejectionHandledHandler");function rt(D){if(0===D[E]){try{const S=v[tt];S&&"function"==typeof S&&S.call(this,{rejection:D[Ee],promise:D})}catch{}D[E]=Re;for(let S=0;S<V.length;S++)D===V[S].promise&&V.splice(S,1)}}function Ce(D,S,b,R,ne){rt(D);const ee=D[E],z=ee?"function"==typeof R?R:pe:"function"==typeof ne?ne:O;S.scheduleMicroTask("Promise.then",()=>{try{const $=D[Ee],te=!!b&&Te===b[Te];te&&(b[re]=$,b[J]=ee);const ye=S.run(z,void 0,te&&z!==O&&z!==pe?[]:[$]);ue(b,!0,ye)}catch($){ue(b,!1,$)}},b)}const H=function(){};class d{static toString(){return"function ZoneAwarePromise() { [native code] }"}static resolve(S){return ue(new this(null),P,S)}static reject(S){return ue(new this(null),Re,S)}static race(S){let b,R,ne=new this(($,te)=>{b=$,R=te});function ee($){b($)}function z($){R($)}for(let $ of S)Ne($)||($=this.resolve($)),$.then(ee,z);return ne}static all(S){return d.allWithCallback(S)}static allSettled(S){return(this&&this.prototype instanceof d?this:d).allWithCallback(S,{thenCallback:R=>({status:"fulfilled",value:R}),errorCallback:R=>({status:"rejected",reason:R})})}static allWithCallback(S,b){let R,ne,ee=new this((ye,Z)=>{R=ye,ne=Z}),z=2,$=0;const te=[];for(let ye of S){Ne(ye)||(ye=this.resolve(ye));const Z=$;try{ye.then(Be=>{te[Z]=b?b.thenCallback(Be):Be,z--,0===z&&R(te)},Be=>{b?(te[Z]=b.errorCallback(Be),z--,0===z&&R(te)):ne(Be)})}catch(Be){ne(Be)}z++,$++}return z-=2,0===z&&R(te),ee}constructor(S){const b=this;if(!(b instanceof d))throw new Error("Must be an instanceof Promise.");b[E]=Pe,b[Ee]=[];try{S&&S(fe(b,P),fe(b,Re))}catch(R){ue(b,!1,R)}}get[Symbol.toStringTag](){return"Promise"}get[Symbol.species](){return d}then(S,b){let R=this.constructor[Symbol.species];(!R||"function"!=typeof R)&&(R=this.constructor||d);const ne=new R(H),ee=v.current;return this[E]==Pe?this[Ee].push(ee,ne,S,b):Ce(this,ee,ne,S,b),ne}catch(S){return this.then(null,S)}finally(S){let b=this.constructor[Symbol.species];(!b||"function"!=typeof b)&&(b=d);const R=new b(H);R[Te]=Te;const ne=v.current;return this[E]==Pe?this[Ee].push(ne,R,S,S):Ce(this,ne,R,S,S),R}}d.resolve=d.resolve,d.reject=d.reject,d.race=d.race,d.all=d.all;const y=f[F]=f.Promise;f.Promise=d;const W=B("thenPatched");function Y(D){const S=D.prototype,b=m(S,"then");if(b&&(!1===b.writable||!b.configurable))return;const R=S.then;S[q]=R,D.prototype.then=function(ne,ee){return new d(($,te)=>{R.call(this,$,te)}).then(ne,ee)},D[W]=!0}return x.patchThen=Y,y&&(Y(y),Bt(f,"fetch",D=>function Ue(D){return function(S,b){let R=D.apply(S,b);if(R instanceof d)return R;let ne=R.constructor;return ne[W]||Y(ne),R}}(D))),Promise[v.__symbol__("uncaughtPromiseErrors")]=V,d}),Zone.__load_patch("toString",f=>{const v=Function.prototype.toString,x=me("OriginalDelegate"),m=me("Promise"),T=me("Error"),I=function(){if("function"==typeof this){const F=this[x];if(F)return"function"==typeof F?v.call(F):Object.prototype.toString.call(F);if(this===Promise){const q=f[m];if(q)return v.call(q)}if(this===Error){const q=f[T];if(q)return v.call(q)}}return v.call(this)};I[x]=v,Function.prototype.toString=I;const B=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":B.call(this)}});let Jt=!1;if(typeof window<"u")try{const f=Object.defineProperty({},"passive",{get:function(){Jt=!0}});window.addEventListener("test",f,f),window.removeEventListener("test",f,f)}catch{Jt=!1}const ci={useG:!0},qe={},pr={},hr=new RegExp("^"+jt+"(\\w+)(true|false)$"),Wt=me("propagationStopped");function xs(f,v){const x=(v?v(f):f)+At,m=(v?v(f):f)+K,T=jt+x,I=jt+m;qe[f]={},qe[f][At]=T,qe[f][K]=I}function pi(f,v,x){const m=x&&x.add||Pn,T=x&&x.rm||ys,I=x&&x.listeners||"eventListeners",B=x&&x.rmAll||"removeAllListeners",V=me(m),j="."+m+":",ge=function(O,E,Ee){if(O.isRemoved)return;const Te=O.callback;"object"==typeof Te&&Te.handleEvent&&(O.callback=J=>Te.handleEvent(J),O.originalDelegate=Te),O.invoke(O,E,[Ee]);const re=O.options;re&&"object"==typeof re&&re.once&&E[T].call(E,Ee.type,O.originalDelegate?O.originalDelegate:O.callback,re)},se=function(O){if(!(O=O||f.event))return;const E=this||O.target||f,Ee=E[qe[O.type][At]];if(Ee)if(1===Ee.length)ge(Ee[0],E,O);else{const Te=Ee.slice();for(let re=0;re<Te.length&&(!O||!0!==O[Wt]);re++)ge(Te[re],E,O)}},de=function(O){if(!(O=O||f.event))return;const E=this||O.target||f,Ee=E[qe[O.type][K]];if(Ee)if(1===Ee.length)ge(Ee[0],E,O);else{const Te=Ee.slice();for(let re=0;re<Te.length&&(!O||!0!==O[Wt]);re++)ge(Te[re],E,O)}};function Ne(O,E){if(!O)return!1;let Ee=!0;E&&void 0!==E.useG&&(Ee=E.useG);const Te=E&&E.vh;let re=!0;E&&void 0!==E.chkDup&&(re=E.chkDup);let J=!1;E&&void 0!==E.rt&&(J=E.rt);let oe=O;for(;oe&&!oe.hasOwnProperty(m);)oe=Le(oe);if(!oe&&O[m]&&(oe=O),!oe||oe[V])return!1;const Pe=E&&E.eventNameToString,P={},Re=oe[V]=oe[m],G=oe[me(T)]=oe[T],fe=oe[me(I)]=oe[I],X=oe[me(B)]=oe[B];let $e;function et(S,b){return!Jt&&"object"==typeof S&&S?!!S.capture:Jt&&b?"boolean"==typeof S?{capture:S,passive:!0}:S?"object"==typeof S&&!1!==S.passive?Object.assign(Object.assign({},S),{passive:!0}):S:{passive:!0}:S}E&&E.prepend&&($e=oe[me(E.prepend)]=oe[E.prepend]);const H=Ee?function(S){if(!P.isExisting)return Re.call(P.target,P.eventName,P.capture?de:se,P.options)}:function(S){return Re.call(P.target,P.eventName,S.invoke,P.options)},d=Ee?function(S){if(!S.isRemoved){const b=qe[S.eventName];let R;b&&(R=b[S.capture?K:At]);const ne=R&&S.target[R];if(ne)for(let ee=0;ee<ne.length;ee++)if(ne[ee]===S){ne.splice(ee,1),S.isRemoved=!0,0===ne.length&&(S.allRemoved=!0,S.target[R]=null);break}}if(S.allRemoved)return G.call(S.target,S.eventName,S.capture?de:se,S.options)}:function(S){return G.call(S.target,S.eventName,S.invoke,S.options)},W=E&&E.diff?E.diff:function(S,b){const R=typeof b;return"function"===R&&S.callback===b||"object"===R&&S.originalDelegate===b},Y=Zone[me("UNPATCHED_EVENTS")],Ue=f[me("PASSIVE_EVENTS")],D=function(S,b,R,ne,ee=!1,z=!1){return function(){const $=this||f;let te=arguments[0];E&&E.transferEventName&&(te=E.transferEventName(te));let ye=arguments[1];if(!ye)return S.apply(this,arguments);if(ce&&"uncaughtException"===te)return S.apply(this,arguments);let Z=!1;if("function"!=typeof ye){if(!ye.handleEvent)return S.apply(this,arguments);Z=!0}if(Te&&!Te(S,ye,$,arguments))return;const Be=Jt&&!!Ue&&-1!==Ue.indexOf(te),it=et(arguments[2],Be);if(Y)for(let Qe=0;Qe<Y.length;Qe++)if(te===Y[Qe])return Be?S.call($,te,ye,it):S.apply(this,arguments);const Gt=!!it&&("boolean"==typeof it||it.capture),ns=!(!it||"object"!=typeof it)&&it.once,Bn=Zone.current;let Fn=qe[te];Fn||(xs(te,Pe),Fn=qe[te]);const On=Fn[Gt?K:At];let _n,Dt=$[On],Ie=!1;if(Dt){if(Ie=!0,re)for(let Qe=0;Qe<Dt.length;Qe++)if(W(Dt[Qe],ye))return}else Dt=$[On]=[];const ss=$.constructor.name,tn=pr[ss];tn&&(_n=tn[te]),_n||(_n=ss+b+(Pe?Pe(te):te)),P.options=it,ns&&(P.options.once=!1),P.target=$,P.capture=Gt,P.eventName=te,P.isExisting=Ie;const ot=Ee?ci:void 0;ot&&(ot.taskData=P);const St=Bn.scheduleEventTask(_n,ye,ot,R,ne);return P.target=null,ot&&(ot.taskData=null),ns&&(it.once=!0),!Jt&&"boolean"==typeof St.options||(St.options=it),St.target=$,St.capture=Gt,St.eventName=te,Z&&(St.originalDelegate=ye),z?Dt.unshift(St):Dt.push(St),ee?$:void 0}};return oe[m]=D(Re,j,H,d,J),$e&&(oe.prependListener=D($e,".prependListener:",function(S){return $e.call(P.target,P.eventName,S.invoke,P.options)},d,J,!0)),oe[T]=function(){const S=this||f;let b=arguments[0];E&&E.transferEventName&&(b=E.transferEventName(b));const R=arguments[2],ne=!!R&&("boolean"==typeof R||R.capture),ee=arguments[1];if(!ee)return G.apply(this,arguments);if(Te&&!Te(G,ee,S,arguments))return;const z=qe[b];let $;z&&($=z[ne?K:At]);const te=$&&S[$];if(te)for(let ye=0;ye<te.length;ye++){const Z=te[ye];if(W(Z,ee))return te.splice(ye,1),Z.isRemoved=!0,0===te.length&&(Z.allRemoved=!0,S[$]=null,"string"==typeof b)&&(S[jt+"ON_PROPERTY"+b]=null),Z.zone.cancelTask(Z),J?S:void 0}return G.apply(this,arguments)},oe[I]=function(){const S=this||f;let b=arguments[0];E&&E.transferEventName&&(b=E.transferEventName(b));const R=[],ne=Ts(S,Pe?Pe(b):b);for(let ee=0;ee<ne.length;ee++){const z=ne[ee];R.push(z.originalDelegate?z.originalDelegate:z.callback)}return R},oe[B]=function(){const S=this||f;let b=arguments[0];if(b){E&&E.transferEventName&&(b=E.transferEventName(b));const R=qe[b];if(R){const z=S[R[At]],$=S[R[K]];if(z){const te=z.slice();for(let ye=0;ye<te.length;ye++){const Z=te[ye];this[T].call(this,b,Z.originalDelegate?Z.originalDelegate:Z.callback,Z.options)}}if($){const te=$.slice();for(let ye=0;ye<te.length;ye++){const Z=te[ye];this[T].call(this,b,Z.originalDelegate?Z.originalDelegate:Z.callback,Z.options)}}}}else{const R=Object.keys(S);for(let ne=0;ne<R.length;ne++){const z=hr.exec(R[ne]);let $=z&&z[1];$&&"removeListener"!==$&&this[B].call(this,$)}this[B].call(this,"removeListener")}if(J)return this},bt(oe[m],Re),bt(oe[T],G),X&&bt(oe[B],X),fe&&bt(oe[I],fe),!0}let pe=[];for(let O=0;O<v.length;O++)pe[O]=Ne(v[O],x);return pe}function Ts(f,v){if(!v){const I=[];for(let B in f){const V=hr.exec(B);let j=V&&V[1];if(j&&(!v||j===v)){const F=f[B];if(F)for(let q=0;q<F.length;q++)I.push(F[q])}}return I}let x=qe[v];x||(xs(v),x=qe[v]);const m=f[x[At]],T=f[x[K]];return m?T?m.concat(T):m.slice():T?T.slice():[]}function dr(f,v){const x=f.Event;x&&x.prototype&&v.patchMethod(x.prototype,"stopImmediatePropagation",m=>function(T,I){T[Wt]=!0,m&&m.apply(T,I)})}function Cs(f,v,x,m,T){const I=Zone.__symbol__(m);if(v[I])return;const B=v[I]=v[m];v[m]=function(V,j,F){return j&&j.prototype&&T.forEach(function(q){const ge=`${x}.${m}::`+q,se=j.prototype;if(se.hasOwnProperty(q)){const de=f.ObjectGetOwnPropertyDescriptor(se,q);de&&de.value?(de.value=f.wrapWithCurrentZone(de.value,ge),f._redefineProperty(j.prototype,q,de)):se[q]&&(se[q]=f.wrapWithCurrentZone(se[q],ge))}else se[q]&&(se[q]=f.wrapWithCurrentZone(se[q],ge))}),B.call(v,V,j,F)},f.attachOriginToPatched(v[m],B)}const As=["absolutedeviceorientation","afterinput","afterprint","appinstalled","beforeinstallprompt","beforeprint","beforeunload","devicelight","devicemotion","deviceorientation","deviceorientationabsolute","deviceproximity","hashchange","languagechange","message","mozbeforepaint","offline","online","paint","pageshow","pagehide","popstate","rejectionhandled","storage","unhandledrejection","unload","userproximity","vrdisplayconnected","vrdisplaydisconnected","vrdisplaypresentchange"],di=["encrypted","waitingforkey","msneedkey","mozinterruptbegin","mozinterruptend"],bs=["load"],Is=["blur","error","focus","load","resize","scroll","messageerror"],Ye=["bounce","finish","start"],Ke=["loadstart","progress","abort","error","load","progress","timeout","loadend","readystatechange"],en=["upgradeneeded","complete","abort","success","error","blocked","versionchange","close"],gi=["close","error","open","message"],He=["error","message"],zt=["abort","animationcancel","animationend","animationiteration","auxclick","beforeinput","blur","cancel","canplay","canplaythrough","change","compositionstart","compositionupdate","compositionend","cuechange","click","close","contextmenu","curechange","dblclick","drag","dragend","dragenter","dragexit","dragleave","dragover","drop","durationchange","emptied","ended","error","focus","focusin","focusout","gotpointercapture","input","invalid","keydown","keypress","keyup","load","loadstart","loadeddata","loadedmetadata","lostpointercapture","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","mousewheel","orientationchange","pause","play","playing","pointercancel","pointerdown","pointerenter","pointerleave","pointerlockchange","mozpointerlockchange","webkitpointerlockerchange","pointerlockerror","mozpointerlockerror","webkitpointerlockerror","pointermove","pointout","pointerover","pointerup","progress","ratechange","reset","resize","scroll","seeked","seeking","select","selectionchange","selectstart","show","sort","stalled","submit","suspend","timeupdate","volumechange","touchcancel","touchmove","touchstart","touchend","transitioncancel","transitionend","waiting","wheel"].concat(["webglcontextrestored","webglcontextlost","webglcontextcreationerror"],["autocomplete","autocompleteerror"],["toggle"],["afterscriptexecute","beforescriptexecute","DOMContentLoaded","freeze","fullscreenchange","mozfullscreenchange","webkitfullscreenchange","msfullscreenchange","fullscreenerror","mozfullscreenerror","webkitfullscreenerror","msfullscreenerror","readystatechange","visibilitychange","resume"],As,["beforecopy","beforecut","beforepaste","copy","cut","paste","dragstart","loadend","animationstart","search","transitionrun","transitionstart","webkitanimationend","webkitanimationiteration","webkitanimationstart","webkittransitionend"],["activate","afterupdate","ariarequest","beforeactivate","beforedeactivate","beforeeditfocus","beforeupdate","cellchange","controlselect","dataavailable","datasetchanged","datasetcomplete","errorupdate","filterchange","layoutcomplete","losecapture","move","moveend","movestart","propertychange","resizeend","resizestart","rowenter","rowexit","rowsdelete","rowsinserted","command","compassneedscalibration","deactivate","help","mscontentzoom","msmanipulationstatechanged","msgesturechange","msgesturedoubletap","msgestureend","msgesturehold","msgesturestart","msgesturetap","msgotpointercapture","msinertiastart","mslostpointercapture","mspointercancel","mspointerdown","mspointerenter","mspointerhover","mspointerleave","mspointermove","mspointerout","mspointerover","mspointerup","pointerout","mssitemodejumplistitemremoved","msthumbnailclick","stop","storagecommit"]);function Er(f,v,x){if(!x||0===x.length)return v;const m=x.filter(I=>I.target===f);if(!m||0===m.length)return v;const T=m[0].ignoreProperties;return v.filter(I=>-1===T.indexOf(I))}function Me(f,v,x,m){f&&ui(f,Er(f,v,x),m)}Zone.__load_patch("util",(f,v,x)=>{x.patchOnProperties=ui,x.patchMethod=Bt,x.bindArguments=st,x.patchMacroTask=li;const m=v.__symbol__("BLACK_LISTED_EVENTS"),T=v.__symbol__("UNPATCHED_EVENTS");f[T]&&(f[m]=f[T]),f[m]&&(v[m]=v[T]=f[m]),x.patchEventPrototype=dr,x.patchEventTarget=pi,x.isIEOrEdge=ws,x.ObjectDefineProperty=Yn,x.ObjectGetOwnPropertyDescriptor=mn,x.ObjectCreate=_t,x.ArraySlice=_s,x.patchClass=Mn,x.wrapWithCurrentZone=Ln,x.filterProperties=Er,x.attachOriginToPatched=bt,x._redefineProperty=Object.defineProperty,x.patchCallbacks=Cs,x.getGlobalObjects=()=>({globalSources:pr,zoneSymbolEventNames:qe,eventNames:zt,isBrowser:Ge,isMix:ur,isNode:ce,TRUE_STR:K,FALSE_STR:At,ZONE_SYMBOL_PREFIX:jt,ADD_EVENT_LISTENER_STR:Pn,REMOVE_EVENT_LISTENER_STR:ys})});const It=me("zoneTask");function En(f,v,x,m){let T=null,I=null;x+=m;const B={};function V(F){const q=F.data;return q.args[0]=function(){return F.invoke.apply(this,arguments)},q.handleId=T.apply(f,q.args),F}function j(F){return I.call(f,F.data.handleId)}T=Bt(f,v+=m,F=>function(q,ge){if("function"==typeof ge[0]){const se={isPeriodic:"Interval"===m,delay:"Timeout"===m||"Interval"===m?ge[1]||0:void 0,args:ge},de=ge[0];ge[0]=function(){try{return de.apply(this,arguments)}finally{se.isPeriodic||("number"==typeof se.handleId?delete B[se.handleId]:se.handleId&&(se.handleId[It]=null))}};const Ne=Jn(v,ge[0],se,V,j);if(!Ne)return Ne;const pe=Ne.data.handleId;return"number"==typeof pe?B[pe]=Ne:pe&&(pe[It]=Ne),pe&&pe.ref&&pe.unref&&"function"==typeof pe.ref&&"function"==typeof pe.unref&&(Ne.ref=pe.ref.bind(pe),Ne.unref=pe.unref.bind(pe)),"number"==typeof pe||pe?pe:Ne}return F.apply(f,ge)}),I=Bt(f,x,F=>function(q,ge){const se=ge[0];let de;"number"==typeof se?de=B[se]:(de=se&&se[It],de||(de=se)),de&&"string"==typeof de.type?"notScheduled"!==de.state&&(de.cancelFn&&de.data.isPeriodic||0===de.runCount)&&("number"==typeof se?delete B[se]:se&&(se[It]=null),de.zone.cancelTask(de)):F.apply(f,ge)})}Zone.__load_patch("legacy",f=>{const v=f[Zone.__symbol__("legacyPatch")];v&&v()}),Zone.__load_patch("queueMicrotask",(f,v,x)=>{x.patchMethod(f,"queueMicrotask",m=>function(T,I){v.current.scheduleMicroTask("queueMicrotask",I[0])})}),Zone.__load_patch("timers",f=>{const v="set",x="clear";En(f,v,x,"Timeout"),En(f,v,x,"Interval"),En(f,v,x,"Immediate")}),Zone.__load_patch("requestAnimationFrame",f=>{En(f,"request","cancel","AnimationFrame"),En(f,"mozRequest","mozCancel","AnimationFrame"),En(f,"webkitRequest","webkitCancel","AnimationFrame")}),Zone.__load_patch("blocking",(f,v)=>{const x=["alert","prompt","confirm"];for(let m=0;m<x.length;m++)Bt(f,x[m],(I,B,V)=>function(j,F){return v.current.run(I,f,F,V)})}),Zone.__load_patch("EventTarget",(f,v,x)=>{(function _r(f,v){v.patchEventPrototype(f,v)})(f,x),function Ei(f,v){if(Zone[v.symbol("patchEventTarget")])return;const{eventNames:x,zoneSymbolEventNames:m,TRUE_STR:T,FALSE_STR:I,ZONE_SYMBOL_PREFIX:B}=v.getGlobalObjects();for(let j=0;j<x.length;j++){const F=x[j],se=B+(F+I),de=B+(F+T);m[F]={},m[F][I]=se,m[F][T]=de}const V=f.EventTarget;V&&V.prototype&&v.patchEventTarget(f,[V&&V.prototype])}(f,x);const m=f.XMLHttpRequestEventTarget;m&&m.prototype&&x.patchEventTarget(f,[m.prototype])}),Zone.__load_patch("MutationObserver",(f,v,x)=>{Mn("MutationObserver"),Mn("WebKitMutationObserver")}),Zone.__load_patch("IntersectionObserver",(f,v,x)=>{Mn("IntersectionObserver")}),Zone.__load_patch("FileReader",(f,v,x)=>{Mn("FileReader")}),Zone.__load_patch("on_property",(f,v,x)=>{!function Ds(f,v){if(ce&&!ur||Zone[f.symbol("patchEvents")])return;const x=typeof WebSocket<"u",m=v.__Zone_ignore_on_properties;if(Ge){const B=window,V=function Ho(){try{const f=gn.navigator.userAgent;if(-1!==f.indexOf("MSIE ")||-1!==f.indexOf("Trident/"))return!0}catch{}return!1}()?[{target:B,ignoreProperties:["error"]}]:[];Me(B,zt.concat(["messageerror"]),m&&m.concat(V),Le(B)),Me(Document.prototype,zt,m),typeof B.SVGElement<"u"&&Me(B.SVGElement.prototype,zt,m),Me(Element.prototype,zt,m),Me(HTMLElement.prototype,zt,m),Me(HTMLMediaElement.prototype,di,m),Me(HTMLFrameSetElement.prototype,As.concat(Is),m),Me(HTMLBodyElement.prototype,As.concat(Is),m),Me(HTMLFrameElement.prototype,bs,m),Me(HTMLIFrameElement.prototype,bs,m);const j=B.HTMLMarqueeElement;j&&Me(j.prototype,Ye,m);const F=B.Worker;F&&Me(F.prototype,He,m)}const T=v.XMLHttpRequest;T&&Me(T.prototype,Ke,m);const I=v.XMLHttpRequestEventTarget;I&&Me(I&&I.prototype,Ke,m),typeof IDBIndex<"u"&&(Me(IDBIndex.prototype,en,m),Me(IDBRequest.prototype,en,m),Me(IDBOpenDBRequest.prototype,en,m),Me(IDBDatabase.prototype,en,m),Me(IDBTransaction.prototype,en,m),Me(IDBCursor.prototype,en,m)),x&&Me(WebSocket.prototype,gi,m)}(x,f)}),Zone.__load_patch("customElements",(f,v,x)=>{!function vi(f,v){const{isBrowser:x,isMix:m}=v.getGlobalObjects();(x||m)&&f.customElements&&"customElements"in f&&v.patchCallbacks(v,f.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback"])}(f,x)}),Zone.__load_patch("XHR",(f,v)=>{!function j(F){const q=F.XMLHttpRequest;if(!q)return;const ge=q.prototype;let de=ge[Qn],Ne=ge[kn];if(!de){const G=F.XMLHttpRequestEventTarget;if(G){const fe=G.prototype;de=fe[Qn],Ne=fe[kn]}}const pe="readystatechange",O="scheduled";function E(G){const fe=G.data,X=fe.target;X[I]=!1,X[V]=!1;const $e=X[T];de||(de=X[Qn],Ne=X[kn]),$e&&Ne.call(X,pe,$e);const et=X[T]=()=>{if(X.readyState===X.DONE)if(!fe.aborted&&X[I]&&G.state===O){const tt=X[v.__symbol__("loadfalse")];if(0!==X.status&&tt&&tt.length>0){const rt=G.invoke;G.invoke=function(){const Ce=X[v.__symbol__("loadfalse")];for(let le=0;le<Ce.length;le++)Ce[le]===G&&Ce.splice(le,1);!fe.aborted&&G.state===O&&rt.call(G)},tt.push(G)}else G.invoke()}else!fe.aborted&&!1===X[I]&&(X[V]=!0)};return de.call(X,pe,et),X[x]||(X[x]=G),P.apply(X,fe.args),X[I]=!0,G}function Ee(){}function Te(G){const fe=G.data;return fe.aborted=!0,Re.apply(fe.target,fe.args)}const re=Bt(ge,"open",()=>function(G,fe){return G[m]=0==fe[2],G[B]=fe[1],re.apply(G,fe)}),oe=me("fetchTaskAborting"),Pe=me("fetchTaskScheduling"),P=Bt(ge,"send",()=>function(G,fe){if(!0===v.current[Pe]||G[m])return P.apply(G,fe);{const X={target:G,url:G[B],isPeriodic:!1,args:fe,aborted:!1},$e=Jn("XMLHttpRequest.send",Ee,X,E,Te);G&&!0===G[V]&&!X.aborted&&$e.state===O&&$e.invoke()}}),Re=Bt(ge,"abort",()=>function(G,fe){const X=function se(G){return G[x]}(G);if(X&&"string"==typeof X.type){if(null==X.cancelFn||X.data&&X.data.aborted)return;X.zone.cancelTask(X)}else if(!0===v.current[oe])return Re.apply(G,fe)})}(f);const x=me("xhrTask"),m=me("xhrSync"),T=me("xhrListener"),I=me("xhrScheduled"),B=me("xhrURL"),V=me("xhrErrorBeforeScheduled")}),Zone.__load_patch("geolocation",f=>{f.navigator&&f.navigator.geolocation&&function Ss(f,v){const x=f.constructor.name;for(let m=0;m<v.length;m++){const T=v[m],I=f[T];if(I){if(!es(mn(f,T)))continue;f[T]=(V=>{const j=function(){return V.apply(this,st(arguments,x+"."+T))};return bt(j,V),j})(I)}}}(f.navigator.geolocation,["getCurrentPosition","watchPosition"])}),Zone.__load_patch("PromiseRejectionEvent",(f,v)=>{function x(m){return function(T){Ts(f,m).forEach(B=>{const V=f.PromiseRejectionEvent;if(V){const j=new V(m,{promise:T.promise,reason:T.rejection});B.invoke(j)}})}}f.PromiseRejectionEvent&&(v[me("unhandledPromiseRejectionHandler")]=x("unhandledrejection"),v[me("rejectionHandledHandler")]=x("rejectionhandled"))})}},or=>{or(or.s=565)}]);